{
	"auto_complete":
	{
		"selected_items":
		[
		]
	},
	"buffers":
	[
		{
			"contents": "/*\n * Copyright (C) Your copyright.\n *\n * Author: Christopher Jordan-Denny\n *\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n//TODO Add doxygen comments.\n#include <unistd.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <linux/types.h>\n#include <linux/spi/spidev.h>\n#include <sys/mman.h>\n\n#include \"lsm9ds1.h\"\n\n#if DEBUG > 0\n#define DEBUG_PRINT(fmt, args...) fprintf(stderr, \"[%s:%d:%s()]: \" fmt, \\\n\t\t__FILE__, __LINE__, __func__, ##args)\n#else\n#define DEBUG_PRINT(fmt, args...) /* Don't do anything in release builds */\n#endif\n\nstatic bool bus_initialized = false;\nstatic uint8_t num_calls = 0;\nstatic lsm9ds1_settings_t device_settings = { 0 };\nstatic uint32_t *gpio_virt_addr = NULL;\nstatic lsm9ds1_devices_t current_device = LSM9DS1_ACCEL_GYRO;\n\n//TODO move these to the correct function\nstatic uint8_t mode;\nstatic uint8_t bits = 8;\nstatic uint32_t speed = 15000000;\nstatic uint16_t delay = 0;\nstatic int32_t fd = -1;\t// File descriptor for LSM9DS1\n\nlsm9ds1_status_t set_current_device(lsm9ds1_devices_t device) {\n\tcurrent_device = device;\n\n\treturn LSM9DS1_SUCCESS;\n}\n\nstatic lsm9ds1_status_t lsm9ds1_mag_cs(pin_state_t pin_state) {\n\n\tuint32_t temp_reg = 0;\n\n\tswitch (pin_state) {\n\tcase HIGH:\n\t\ttemp_reg = gpio_virt_addr[7];\n\t\tgpio_virt_addr[7] = temp_reg | (1 << 22);\n\t\tbreak;\n\tcase LOW:\n\t\ttemp_reg = gpio_virt_addr[10];\n\t\tgpio_virt_addr[10] = temp_reg | (1 << 22);\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn LSM9DS1_SUCCESS;\n}\n\nstatic lsm9ds1_status_t transfer(lsm9ds1_devices_t device, lsm9ds1_xfer_t op,\n                                 uint8_t address, uint8_t tx, uint8_t *rx) {\n\n\tint8_t ret = LSM9DS1_UNKNOWN_ERROR;\n\n\tswitch (device) {\n\tcase LSM9DS1_MAG:\n\n\t\tmode |= SPI_NO_CS;\n\t\tret = ioctl(fd, SPI_IOC_WR_MODE, &mode);\n\t\tif (ret == -1) {\n\t\t\treturn LSM9DS1_UNABLE_TO_SET_CS;\n\t\t}\n\n\t\t(void) lsm9ds1_mag_cs(LOW);\n\n\t\tbreak;\n\tcase LSM9DS1_ACCEL_GYRO:\n\t\t// Make sure CS is selected.\n\t\tmode &= ~(SPI_NO_CS);\n\t\tret = ioctl(fd, SPI_IOC_WR_MODE, &mode);\n\t\tif (ret == -1) {\n\t\t\treturn LSM9DS1_UNABLE_TO_SET_CS;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\treturn LSM9DS1_UNKNOWN_SUB_DEVICE;\n\t}\n\n\tuint8_t addr_xfer = 0;\n\n\t//TODO ensure sizes are correct\n\tstruct spi_ioc_transfer tr[2] = { 0 };\n\n\tswitch (op) {\n\tcase LSM9DS1_READ:\n\t\ttr[1].rx_buf = (unsigned long) rx;\n\t\ttr[1].len = sizeof(*rx);\n\t\ttr[1].speed_hz = speed;\n\t\ttr[1].delay_usecs = delay;\n\t\ttr[1].bits_per_word = bits;\n\n\t\taddr_xfer = (SPI_READ | address);\n\t\tbreak;\n\tcase LSM9DS1_WRITE:\n\t\ttr[1].tx_buf = (unsigned long) &tx;\n\t\ttr[1].len = sizeof(tx);\n\t\ttr[1].speed_hz = speed;\n\t\ttr[1].delay_usecs = delay;\n\t\ttr[1].bits_per_word = bits;\n\n\t\tif (NULL != rx) {\n\t\t\trx = NULL;\n\t\t}\n\n\t\taddr_xfer = (SPI_WRITE | address);\n\t\tbreak;\n\tdefault:\n\t\treturn LSM9DS1_UNSUPPORTED_OP;\n\t}\n\n\t// Setup the address to w/r\n\ttr[0].tx_buf = (unsigned long) &addr_xfer;\n\ttr[0].len = sizeof(tx);\n\ttr[0].speed_hz = speed;\n\ttr[0].delay_usecs = delay;\n\ttr[0].bits_per_word = bits;\n\n\tret = ioctl(fd, SPI_IOC_MESSAGE(2), tr);\n\tif (LSM9DS1_MAG == device) {\n\t\t// Set back to high after the message was sent.\n\t\t(void) lsm9ds1_mag_cs(HIGH);\n\t}\n\tDEBUG_PRINT(\"SPIDEV: transfer(%d)\\n\", ret);\n\tif (ret < 1) {\n\t\treturn LSM9DS1_SPI_BUS_XFER_ERROR;\n\t}\n\n\treturn LSM9DS1_SUCCESS;\n}\n\nstatic lsm9ds1_status_t lsm9ds1_write(lsm9ds1_devices_t device,\n                                      uint8_t register_addr, uint8_t tx) {\n\n\tlsm9ds1_status_t ret = LSM9DS1_UNKNOWN_ERROR;\n\n\t//RX doesn't matter so give it NULL\n\tret = transfer(device, LSM9DS1_WRITE, register_addr, tx, NULL);\n\n\treturn ret;\n}\n\nstatic lsm9ds1_status_t lsm9ds1_read(lsm9ds1_devices_t device,\n                                     uint8_t register_addr, uint8_t *rx) {\n\n\tlsm9ds1_status_t ret = LSM9DS1_UNKNOWN_ERROR;\n\n\t// tx doesn't matter, so just use 0.\n\tret = transfer(device, LSM9DS1_READ, register_addr, 0, rx);\n\n\treturn ret;\n}\n\nstatic lsm9ds1_status_t lsm9ds1_setup_mag_cs() {\n\t//Setup for Mag CS\n\tstatic int fd_gpio = -1;\n\n\tfd_gpio = open(\"/dev/gpiomem\", O_RDWR);\n\tif (fd_gpio < 0) {\n\t\tDEBUG_PRINT(\"Error opening /dev/gpiomem\\n\");\n\n\t\treturn LSM9DS1_UNABLE_TO_OPEN_MAG_CS;\n\t}\n\tDEBUG_PRINT(\"Opened /dev/gpiomem\\n\");\n\n\tlong page_size = sysconf(_SC_PAGESIZE);\n\tgpio_virt_addr = mmap(NULL, page_size, PROT_READ | PROT_WRITE, MAP_SHARED,\n\t                      fd_gpio, 0);\n\tif (gpio_virt_addr == MAP_FAILED) {\n\t\treturn LSM9DS1_UNABLE_TO_OPEN_MAG_CS;\n\t}\n\n\tif (NULL == gpio_virt_addr) {\n\t\treturn LSM9DS1_UNABLE_TO_OPEN_MAG_CS;\n\t}\n\n\tDEBUG_PRINT(\"mmap'd gpiomem at pointer %p\\n\", gpio_virt_addr);\n\n\t// Setup CS as output\n\tDEBUG_PRINT(\"Setting mag CS as output\\n\");\n\tuint32_t temp_reg = 0;\n#define GPIO_FUNCTION_MASK 0xFFFFFE3F\n\ttemp_reg = gpio_virt_addr[2];\n\tDEBUG_PRINT(\"GPIO Read Settings 0x%X\\n\", temp_reg);\n\ttemp_reg &= GPIO_FUNCTION_MASK;\n\ttemp_reg |= (1 << 6);\n\tDEBUG_PRINT(\"GPIO Write Settings 0x%X\\n\", temp_reg);\n\n\tgpio_virt_addr[2] = temp_reg;\n\n\treturn LSM9DS1_SUCCESS;\n}\n\nlsm9ds1_status_t lsm9ds1_setup_mag(lsm9ds1_mag_gain_t gain) {\n\n\tif (!bus_initialized) {\n\t\treturn LSM9DS1_BUS_NOT_INTIALIZED;\n\t}\n\n\tlsm9ds1_status_t read_status = LSM9DS1_UNKNOWN_ERROR;\n\n\t// CS logic low, so set to high to ignore.\n\t(void) lsm9ds1_mag_cs(HIGH);\n\n\t// Ensure we have the correct device\n\t(void) set_current_device(LSM9DS1_MAG);\n\tlsm9ds1_devices_t sub_device = LSM9DS1_UNKNOWN_DEVICE;\n\tlsm9ds1_read_sub_device(&sub_device);\n\tif (!(LSM9DS1_MAG == sub_device)) {\n\t\treturn LSM9DS1_UNKNOWN_SUB_DEVICE;\n\t}\n\n\t// Read the accelerometer.\n\tuint8_t read_buffer = 0;\n\tread_status = lsm9ds1_read(LSM9DS1_MAG, LSM9DS1_REGISTER_CTRL_REG2_M,\n\t                           &read_buffer);\n\tif (read_status < 0) {\n\t\treturn read_status;\n\t}\n\n\tuint8_t reg = read_buffer;\n\treg &= ~(0b01100000);\n\treg |= gain;\n\n\tlsm9ds1_status_t write_status = LSM9DS1_UNKNOWN_ERROR;\n\twrite_status = lsm9ds1_write(LSM9DS1_MAG, LSM9DS1_REGISTER_CTRL_REG2_M,\n\t                             reg);\n\tif (write_status < 0) {\n\t\treturn write_status;\n\t}\n\n\tswitch (gain) {\n\tcase LSM9DS1_MAGGAIN_4GAUSS:\n\t\tdevice_settings.gain = gain;\n\t\tbreak;\n\tcase LSM9DS1_MAGGAIN_8GAUSS:\n\t\tdevice_settings.gain = gain;\n\t\tbreak;\n\tcase LSM9DS1_MAGGAIN_12GAUSS:\n\t\tdevice_settings.gain = gain;\n\t\tbreak;\n\tcase LSM9DS1_MAGGAIN_16GAUSS:\n\t\tdevice_settings.gain = gain;\n\t\tbreak;\n\tdefault:\n\t\treturn LSM9DS1_UKNOWN_GAIN_RANGE;\n\t}\n\n\treturn LSM9DS1_SUCCESS;\n}\n\nlsm9ds1_status_t lsm9ds1_setup_accel(lsm9ds1_accel_range_t range) {\n\n\tif (!bus_initialized) {\n\t\treturn LSM9DS1_BUS_NOT_INTIALIZED;\n\t}\n\n\tlsm9ds1_status_t read_status = LSM9DS1_UNKNOWN_ERROR;\n\n\t// Ensure we have the correct device\n\t(void) set_current_device(LSM9DS1_ACCEL_GYRO);\n\tlsm9ds1_devices_t sub_device = LSM9DS1_UNKNOWN_DEVICE;\n\tlsm9ds1_read_sub_device(&sub_device);\n\tif (!(LSM9DS1_ACCEL_GYRO == sub_device)) {\n\t\treturn LSM9DS1_UNKNOWN_SUB_DEVICE;\n\t}\n\n\t// Read the accelerometer.\n\tuint8_t read_buffer = 0;\n\tread_status = lsm9ds1_read(LSM9DS1_ACCEL_GYRO,\n\t                           LSM9DS1_REGISTER_CTRL_REG6_XL, &read_buffer);\n\tif (read_status < 0) {\n\t\treturn read_status;\n\t}\n\tuint8_t reg = read_buffer;\n\treg &= ~(0b00011000);\n\treg |= range;\n\n\tDEBUG_PRINT(\"Setting LSM9DS1_REGISTER_CTRL_REG6_XL: %d\\n\", reg);\n\tlsm9ds1_status_t write_status = LSM9DS1_UNKNOWN_ERROR;\n\twrite_status = lsm9ds1_write(LSM9DS1_ACCEL_GYRO,\n\t                             LSM9DS1_REGISTER_CTRL_REG6_XL, reg);\n\tif (write_status < 0) {\n\t\treturn write_status;\n\t}\n\n\tswitch (range) {\n\tcase LSM9DS1_ACCELRANGE_2G:\n\t\tdevice_settings.range = range;\n\t\tbreak;\n\tcase LSM9DS1_ACCELRANGE_4G:\n\t\tdevice_settings.range = range;\n\t\tbreak;\n\tcase LSM9DS1_ACCELRANGE_8G:\n\t\tdevice_settings.range = range;\n\t\tbreak;\n\tcase LSM9DS1_ACCELRANGE_16G:\n\t\tdevice_settings.range = range;\n\t\tbreak;\n\tdefault:\n\t\treturn LSM9DS1_UKNOWN_ACCEL_RANGE;\n\t\tbreak;\n\t}\n\n\treturn LSM9DS1_SUCCESS;\n}\n\nlsm9ds1_status_t lsm9ds1_setup_gyro(lsm9ds1_gyro_scale_t scale) {\n\n\tif (!bus_initialized) {\n\t\treturn LSM9DS1_BUS_NOT_INTIALIZED;\n\t}\n\n\tlsm9ds1_status_t read_status = LSM9DS1_UNKNOWN_ERROR;\n\n\t// Ensure we have the correct device\n\t(void) set_current_device(LSM9DS1_ACCEL_GYRO);\n\tlsm9ds1_devices_t sub_device = LSM9DS1_UNKNOWN_DEVICE;\n\tlsm9ds1_read_sub_device(&sub_device);\n\tif (!(LSM9DS1_ACCEL_GYRO == sub_device)) {\n\t\treturn LSM9DS1_UNKNOWN_SUB_DEVICE;\n\t}\n\n\t// Read the accelerometer.\n\tuint8_t read_buffer = 0;\n\tread_status = lsm9ds1_read(LSM9DS1_ACCEL_GYRO, LSM9DS1_REGISTER_CTRL_REG1_G,\n\t                           &read_buffer);\n\tif (read_status < 0) {\n\t\treturn read_status;\n\t}\n\tuint8_t reg = read_buffer;\n\n\treg &= ~(0b00011000);\n\treg |= scale;\n\n\tlsm9ds1_status_t write_status = LSM9DS1_UNKNOWN_ERROR;\n\twrite_status = lsm9ds1_write(LSM9DS1_ACCEL_GYRO,\n\t                             LSM9DS1_REGISTER_CTRL_REG1_G, reg);\n\tif (write_status < 0) {\n\t\treturn write_status;\n\t}\n\n\tswitch (scale) {\n\tcase LSM9DS1_GYROSCALE_245DPS:\n\t\tdevice_settings.scale = LSM9DS1_GYROSCALE_245DPS;\n\t\tbreak;\n\tcase LSM9DS1_GYROSCALE_500DPS:\n\t\tdevice_settings.scale = LSM9DS1_GYROSCALE_245DPS;\n\t\tbreak;\n\tcase LSM9DS1_GYROSCALE_2000DPS:\n\t\tdevice_settings.scale = LSM9DS1_GYROSCALE_245DPS;\n\t\tbreak;\n\tdefault:\n\t\treturn LSM9DS1_UKNOWN_GAIN_RANGE;\n\t}\n\n\treturn LSM9DS1_SUCCESS;\n}\nstatic lsm9ds1_status_t init_spi(void) {\n\n\tint8_t ret = -1;\t// Function return codes.\n\n\tfd = open(DEVICE, O_RDWR);\n\tif (fd < 0) {\n\t\treturn LSM9DS1_NOT_FOUND;\n\t}\n\n\t// Set to mode 3\n\tmode |= SPI_CPOL | SPI_CPHA;\n\tret = ioctl(fd, SPI_IOC_WR_MODE, &mode);\n\tif (ret == -1) {\n\t\treturn LSM9DS1_MODE_3_NOT_SET;\n\t}\n\n\t// Set the number of bits per word.\n\tret = ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &bits);\n\tif (ret == -1) {\n\t\treturn LSM9DS1_NUM_BITS_NOT_SET;\n\t}\n\n\t// Set the max clock speed in hz\n\tret = ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &speed);\n\tif (ret == -1) {\n\t\treturn LSM9DS1_CLOCK_NOT_SET;\n\t}\n\n\treturn LSM9DS1_SUCCESS;\n}\n\nstatic lsm9ds1_status_t init_i2c(void) {\n\t// Probably won't implement for raspberrypi\n\treturn LSM9DS1_BUS_NOT_SUPPORTED;\n}\n\nlsm9ds1_status_t lsm9ds1_read_sub_device(lsm9ds1_devices_t *device_id) {\n\n\tlsm9ds1_status_t function_return = LSM9DS1_UNKNOWN_ERROR;\n\tuint8_t read_buffer = LSM9DS1_UNKNOWN_DEVICE;\n\t*device_id = LSM9DS1_UNKNOWN_DEVICE;\n\n\t// The mag accel and gyro id should be at the same offset, if not, we don't know what device we have.\n\t// We are comparing enums of different types, cast first since we want to do this.\n\tif (!((int) LSM9DS1_REGISTER_WHO_AM_I_XG\n\t        == (int) LSM9DS1_REGISTER_WHO_AM_I_M)) {\n\t\treturn LSM9DS1_UNKNOWN_SUB_DEVICE;\n\t}\n\n\t// Discover device\n\tfunction_return = lsm9ds1_read(current_device, LSM9DS1_REGISTER_WHO_AM_I,\n\t                               &read_buffer);\n\tlsm9ds1_devices_t found_device = read_buffer;\n\tDEBUG_PRINT(\"Sub-device: (%d)\\n\", found_device);\n\t// Did we find a the gyro and accel combo or mag?\n\tif ((LSM9DS1_ACCEL_GYRO == found_device) || (LSM9DS1_MAG == found_device)) {\n\t\t*device_id = found_device;\n\t}\n\n\treturn function_return;\n}\n\nstatic lsm9ds1_status_t lsm9ds1_is_init(bool *initialized) {\n\n\tbool has_been_init = false;\n\tif (num_calls > 0) {\n\t\thas_been_init = true;\n\t}\n\n\t*initialized = has_been_init;\n\n\treturn LSM9DS1_SUCCESS;\n}\n\nlsm9ds1_status_t lsm9ds1_init_bus(lsm9ds1_bus_t bus_type) {\n\n\tif (bus_initialized) {\n\t\treturn LSM9DS1_SUCCESS;\n\t}\n\n\t//TODO decide if we need to remove\n\t// If we have already opened the fd then return early\n\tif (fd >= 0) {\n\t\treturn LSM9DS1_SUCCESS;\n\t}\n\n\t// Determine bus type being used.\n\tint8_t ret = -1;\t// Function return codes.\n\tswitch (bus_type) {\n\tcase LSM9DS1_SPI_BUS:\n\t\tret = init_spi();\n\t\tbreak;\n\tcase LSM9DS1_I2C_BUS:\n\t\tret = init_i2c();\n\t\tbreak;\n\tdefault:\n\t\tret = LSM9DS1_BUS_NOT_SUPPORTED;\n\t\tbreak;\n\n\t}\n\n\tbus_initialized = true;\n\treturn ret;\n}\n\nlsm9ds1_status_t lsm9ds1_init(lsm9ds1_bus_t bus_type,\n                              lsm9ds1_accel_range_t range, lsm9ds1_mag_gain_t gain,\n                              lsm9ds1_gyro_scale_t scale) {\n\n\tDEBUG_PRINT(\"Build Version: %s\\n\", BUILD_VERSION);\n\tDEBUG_PRINT(\"Build Date/Time: %s %s\\n\", __DATE__, __TIME__);\n\n\tlsm9ds1_status_t ret = LSM9DS1_UNKNOWN_ERROR;\n\n\t//reset number of calls if necessary\n\tif (num_calls == UINT8_MAX) {\n\t\tnum_calls = 0;\n\t}\n\tnum_calls++;\n\n\tDEBUG_PRINT(\"Initializing the lsm9ds1 bus...\\n\");\n\tret = lsm9ds1_init_bus(bus_type);\n\tif (ret < 0) {\n\t\treturn ret;\n\t};\n\n\tDEBUG_PRINT(\"Setting up accelerometer... range(%d)\\n\", range);\n\tret = lsm9ds1_setup_accel(range);\n\tif (ret < 0) {\n\t\treturn ret;\n\t};\n\n\tDEBUG_PRINT(\"Setting up gyroscope... scale(%d)\\n\", scale);\n\tlsm9ds1_setup_gyro(scale);\n\tif (ret < 0) {\n\t\treturn ret;\n\t};\n\n\t// Setup the magnetometer, this only needs to be done once.\n\tDEBUG_PRINT(\"Setting up mag cs...\\n\");\n\tret = lsm9ds1_setup_mag_cs();\n\tif (ret < 0) {\n\t\tDEBUG_PRINT(\"Error setting up mag cs!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = lsm9ds1_setup_mag(gain);\n\tif (ret < 0) {\n\t\tDEBUG_PRINT(\"Error setting up mag!\\n\");\n\t\treturn ret;\n\t};\n\n\treturn LSM9DS1_SUCCESS;\n}\n\nlsm9ds1_status_t lsm9ds1_read_accel(accelerometer_data_t *accel_data) {\n\n\t// Check that the lsm9ds1 has been initialized.\n\tbool lsm9ds1_initialized = false;\n\t(void) lsm9ds1_is_init(&lsm9ds1_initialized);\n\tif (!lsm9ds1_initialized) {\n\t\treturn LSM9DS1_NOT_INITIALIZED;\n\t}\n\n\tlsm9ds1_status_t read_status = LSM9DS1_UNKNOWN_ERROR;\n\n\t// Ensure we have the correct device\n\t(void) set_current_device(LSM9DS1_ACCEL_GYRO);\n\tlsm9ds1_devices_t sub_device = LSM9DS1_UNKNOWN_DEVICE;\n\tlsm9ds1_read_sub_device(&sub_device);\n\tif (!(LSM9DS1_ACCEL_GYRO == sub_device)) {\n\t\treturn LSM9DS1_UNKNOWN_SUB_DEVICE;\n\t}\n\n\t// Read the accelerometer.\n\tuint8_t read_buffer = 0;\n\tread_status = lsm9ds1_read(LSM9DS1_ACCEL_GYRO, LSM9DS1_REGISTER_OUT_X_L_XL,\n\t                           &read_buffer);\n\tif (read_status < 0) {\n\t\treturn read_status;\n\t}\n\tuint8_t xlo = read_buffer;\n\n\tread_status = lsm9ds1_read(LSM9DS1_ACCEL_GYRO, LSM9DS1_REGISTER_OUT_X_H_XL,\n\t                           &read_buffer);\n\tif (read_status < 0) {\n\t\treturn read_status;\n\t}\n\tint16_t xhi = read_buffer;\n\n\tread_status = lsm9ds1_read(LSM9DS1_ACCEL_GYRO, LSM9DS1_REGISTER_OUT_Y_L_XL,\n\t                           &read_buffer);\n\tif (read_status < 0) {\n\t\treturn read_status;\n\t}\n\tuint8_t ylo = read_buffer;\n\n\tread_status = lsm9ds1_read(LSM9DS1_ACCEL_GYRO, LSM9DS1_REGISTER_OUT_Y_H_XL,\n\t                           &read_buffer);\n\tif (read_status < 0) {\n\t\treturn read_status;\n\t}\n\tint16_t yhi = read_buffer;\n\n\tread_status = lsm9ds1_read(LSM9DS1_ACCEL_GYRO, LSM9DS1_REGISTER_OUT_Z_L_XL,\n\t                           &read_buffer);\n\tif (read_status < 0) {\n\t\treturn read_status;\n\t}\n\tuint8_t zlo = read_buffer;\n\n\tread_status = lsm9ds1_read(LSM9DS1_ACCEL_GYRO, LSM9DS1_REGISTER_OUT_Z_H_XL,\n\t                           &read_buffer);\n\tif (read_status < 0) {\n\t\treturn read_status;\n\t}\n\tint16_t zhi = read_buffer;\n\n\t// Shift values to create properly formed integer (low byte first)\n\txhi <<= 8;\n\txhi |= xlo;\n\tyhi <<= 8;\n\tyhi |= ylo;\n\tzhi <<= 8;\n\tzhi |= zlo;\n\n\taccel_data->x = xhi;\n\taccel_data->y = yhi;\n\taccel_data->z = zhi;\n\n\treturn LSM9DS1_SUCCESS;\n}\n\nlsm9ds1_status_t lsm9ds1_read_mag(mag_data_t *mag_data) {\n\n\t// Check that the lsm9ds1 has been initialized.\n\tbool lsm9ds1_initialized = false;\n\t(void) lsm9ds1_is_init(&lsm9ds1_initialized);\n\tif (!lsm9ds1_initialized) {\n\t\treturn LSM9DS1_NOT_INITIALIZED;\n\t}\n\n\tlsm9ds1_status_t read_status = LSM9DS1_UNKNOWN_ERROR;\n\n\t// Ensure we have the correct device\n\t(void) set_current_device(LSM9DS1_ACCEL_GYRO);\n\tlsm9ds1_devices_t sub_device = LSM9DS1_UNKNOWN_DEVICE;\n\tlsm9ds1_read_sub_device(&sub_device);\n\tif (!(LSM9DS1_MAG == sub_device)) {\n\t\treturn LSM9DS1_UNKNOWN_SUB_DEVICE;\n\t}\n\n\t// Read the accelerometer.\n\tuint8_t read_buffer = 0;\n\tread_status = lsm9ds1_read(LSM9DS1_MAG, LSM9DS1_REGISTER_OUT_X_L_G,\n\t                           &read_buffer);\n\tif (read_status < 0) {\n\t\treturn read_status;\n\t}\n\tuint8_t xlo = read_buffer;\n\n\tread_status = lsm9ds1_read(LSM9DS1_MAG, LSM9DS1_REGISTER_OUT_X_H_G,\n\t                           &read_buffer);\n\tif (read_status < 0) {\n\t\treturn read_status;\n\t}\n\tint16_t xhi = read_buffer;\n\n\tread_status = lsm9ds1_read(LSM9DS1_MAG, LSM9DS1_REGISTER_OUT_Y_L_G,\n\t                           &read_buffer);\n\tif (read_status < 0) {\n\t\treturn read_status;\n\t}\n\tuint8_t ylo = read_buffer;\n\n\tread_status = lsm9ds1_read(LSM9DS1_MAG, LSM9DS1_REGISTER_OUT_Y_H_G,\n\t                           &read_buffer);\n\tif (read_status < 0) {\n\t\treturn read_status;\n\t}\n\tint16_t yhi = read_buffer;\n\n\tread_status = lsm9ds1_read(LSM9DS1_MAG, LSM9DS1_REGISTER_OUT_Z_L_G,\n\t                           &read_buffer);\n\tif (read_status < 0) {\n\t\treturn read_status;\n\t}\n\tuint8_t zlo = read_buffer;\n\n\tread_status = lsm9ds1_read(LSM9DS1_MAG, LSM9DS1_REGISTER_OUT_Z_H_G,\n\t                           &read_buffer);\n\tif (read_status < 0) {\n\t\treturn read_status;\n\t}\n\tint16_t zhi = read_buffer;\n\n\t// Shift values to create properly formed integer (low byte first)\n\txhi <<= 8;\n\txhi |= xlo;\n\tyhi <<= 8;\n\tyhi |= ylo;\n\tzhi <<= 8;\n\tzhi |= zlo;\n\n\tmag_data->x = xhi;\n\tmag_data->y = yhi;\n\tmag_data->z = zhi;\n\n\treturn LSM9DS1_SUCCESS;\n}\n\nlsm9ds1_status_t lsm9ds1_read_temp(lsm9ds1_temperature_t *temp) {\n\n\t// Check that the lsm9ds1 has been initialized.\n\tbool lsm9ds1_initialized = false;\n\t(void) lsm9ds1_is_init(&lsm9ds1_initialized);\n\tif (!lsm9ds1_initialized) {\n\t\treturn LSM9DS1_NOT_INITIALIZED;\n\t}\n\n\tlsm9ds1_status_t read_status = LSM9DS1_UNKNOWN_ERROR;\n\n\t// Ensure we have the correct device\n\t(void) set_current_device(LSM9DS1_ACCEL_GYRO);\n\tlsm9ds1_devices_t sub_device = LSM9DS1_UNKNOWN_DEVICE;\n\tlsm9ds1_read_sub_device(&sub_device);\n\tif (!(LSM9DS1_ACCEL_GYRO == sub_device)) {\n\t\treturn LSM9DS1_UNKNOWN_SUB_DEVICE;\n\t}\n\n\t// Read the accelerometer.\n\tuint8_t read_buffer = 0;\n\tread_status = lsm9ds1_read(LSM9DS1_ACCEL_GYRO, LSM9DS1_REGISTER_TEMP_OUT_L,\n\t                           &read_buffer);\n\tif (read_status < 0) {\n\t\treturn read_status;\n\t}\n\tuint8_t xlo = read_buffer;\n\n\tread_status = lsm9ds1_read(LSM9DS1_ACCEL_GYRO, LSM9DS1_REGISTER_TEMP_OUT_H,\n\t                           &read_buffer);\n\tif (read_status < 0) {\n\t\treturn read_status;\n\t}\n\tlsm9ds1_temperature_t xhi = read_buffer;\n\n\txhi <<= 8;\n\txhi |= xlo;\n\n\t// Shift values to create properly formed integer (low byte first)\n\t*temp = xhi;\n\n\treturn LSM9DS1_SUCCESS;\n}\n\n",
			"file": "src/lsm9ds1.c",
			"file_size": 18342,
			"file_write_time": 132040897824294953,
			"settings":
			{
				"buffer_size": 19058,
				"line_ending": "Unix"
			}
		},
		{
			"file": "lsm9ds1.sublime-project",
			"settings":
			{
				"buffer_size": 287,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Package Control Messages\n========================\n\nSublimeAStyleFormatter\n----------------------\n\n  SublimeAStyleFormatter\n  ======================\n  \n  SublimeAStyleFormatter is a simple code formatter plugin for Sublime Text 2.\n  It provides ability to format C, C++, C#, and Java files.\n  \n  Usage\n  -----\n  ### Key Bindings\n  The default key bindings for this plugin:\n  \n  **Windows, Linux:**\n  + `ctrl+alt+f`: Format current file\n  + `ctrl+k, ctrl+f`: Format current selection\n  \n  **OSX:**\n  + `ctrl+alt+f`: Format current file\n  + `super+k,super+f`: Format current selection\n  \n  ### Command Palette\n  Open the command palette, it apperas as `SublimeAStyleFormatter: Format Current File`\n  and `SublimeAStyleFormatter Format Current Selection`.\n",
			"settings":
			{
				"buffer_size": 752,
				"line_ending": "Unix",
				"name": "Package Control Messages",
				"read_only": true,
				"scratch": true
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"Insta",
				"Package Control: Install Package"
			],
			[
				"About",
				"About"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/christopher/Documents/lsm9ds1",
		"/home/christopher/Documents/lsm9ds1/src"
	],
	"file_history":
	[
		"/home/christopher/Documents/lsm9ds1/src/lsm9ds1_wrap.c",
		"/home/christopher/Documents/lsm9ds1/inc/lsm9ds1.h",
		"/home/christopher/Documents/lsm9ds1/src/lsm9ds1.c",
		"/home/christopher/Documents/lsm9ds1/build.sh",
		"/home/christopher/Documents/lsm9ds1/lsm9ds1.sublime-build",
		"/home/christopher/.config/sublime-text-3/Packages/User/rpi.sublime-build",
		"/home/christopher/Documents/lsm9ds1/lsm9ds1.sublime-project",
		"/home/christopher/Documents/lsm9ds1/poky.sublime-build",
		"/home/christopher/Documents/lsm9ds1/build_settings.sh"
	],
	"find":
	{
		"height": 0.0
	},
	"find_in_files":
	{
		"height": 101.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 2,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "src/lsm9ds1.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 19058,
						"regions":
						{
						},
						"selection":
						[
							[
								1426,
								1426
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 207.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "lsm9ds1.sublime-project",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 287,
						"regions":
						{
						},
						"selection":
						[
							[
								287,
								287
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JSON.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 2,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 752,
						"regions":
						{
						},
						"selection":
						[
							[
								300,
								300
							]
						],
						"settings":
						{
							"auto_indent": false,
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_width": 2,
							"word_wrap": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 0.0
	},
	"input":
	{
		"height": 38.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.astyle_error_message":
	{
		"height": 0.0
	},
	"output.exec":
	{
		"height": 120.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "poky",
	"project": "lsm9ds1.sublime-project",
	"replace":
	{
		"height": 0.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 278.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
